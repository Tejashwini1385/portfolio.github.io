<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>In-Store Product Locator - Auto Dijkstra Trace</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #fefefe;
      color: #222;
      display: flex;
      flex-direction: row;
      gap: 40px;
    }
    h1 {
      color: #005a9c;
    }
    .visual-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    svg {
      border: 1px solid #ccc;
      background: #fff;
    }
    circle.node {
      fill: #ddd;
      stroke: #666;
      stroke-width: 2px;
    }
    circle.node.start {
      fill: #4CAF50;
    }
    circle.node.target {
      fill: #f44336;
    }
    circle.node.visited {
      fill: #ffeb3b;
    }
    line.edge {
      stroke: #999;
      stroke-width: 2px;
    }
    line.edge.highlight {
      stroke: #2196f3;
      stroke-width: 4px;
    }
    text.label {
      font-size: 14px;
      user-select: none;
      pointer-events: none;
    }
    #log {
      margin-top: 15px;
      padding: 10px;
      background: #eee;
      max-width: 400px;
      font-family: monospace;
      white-space: pre-wrap;
      border-radius: 4px;
    }
    .table-section {
      flex-shrink: 0;
      min-width: 250px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      background: #fafafa;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 6px 8px;
      text-align: center;
    }
    th {
      background: #005a9c;
      color: #fff;
    }
    caption {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 16px;
    }
  </style>
</head>
<body>

<div class="visual-section">
  <h1>In-Store Product Locator</h1>
  <svg width="400" height="300" aria-label="Store layout graph visualization"></svg>
  <div id="log"></div>
</div>

<div class="table-section">
  <table id="distTable">
    <caption>Node Distances</caption>
    <thead>
      <tr><th>Node</th><th>Distance</th><th>Predecessor</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
const graph = {
  A: { B: 4, C: 2 },
  B: { A: 4, C: 1, D: 5 },
  C: { A: 2, B: 1, D: 8, E: 10 },
  D: { B: 5, C: 8, E: 2, F: 6 },
  E: { C: 10, D: 2, F: 3 },
  F: { D: 6, E: 3 }
};

const nodePositions = {
  A: {x: 50, y: 150},
  B: {x: 120, y: 60},
  C: {x: 120, y: 240},
  D: {x: 220, y: 100},
  E: {x: 250, y: 230},
  F: {x: 330, y: 150}
};

const svg = document.querySelector("svg");
const logDiv = document.getElementById("log");
const tableBody = document.querySelector("#distTable tbody");

let startNode = "A";
let targetNode = "F";
let distances = {}, predecessors = {}, visited = new Set(), queue = [];

function drawGraph() {
  svg.innerHTML = "";
  for (const [node, neighbors] of Object.entries(graph)) {
    const start = nodePositions[node];
    for (const [neighbor, weight] of Object.entries(neighbors)) {
      if (node < neighbor) {
        const end = nodePositions[neighbor];
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", start.x);
        line.setAttribute("y1", start.y);
        line.setAttribute("x2", end.x);
        line.setAttribute("y2", end.y);
        line.classList.add("edge");
        line.setAttribute("data-edge", `${node}-${neighbor}`);
        svg.appendChild(line);

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", (start.x + end.x)/2);
        text.setAttribute("y", (start.y + end.y)/2 - 5);
        text.classList.add("label");
        text.textContent = weight;
        svg.appendChild(text);
      }
    }
  }

  for (const [node, pos] of Object.entries(nodePositions)) {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", pos.x);
    circle.setAttribute("cy", pos.y);
    circle.setAttribute("r", 16);
    circle.classList.add("node");
    if (node === startNode) circle.classList.add("start");
    if (node === targetNode) circle.classList.add("target");
    circle.setAttribute("id", `node-${node}`);
    svg.appendChild(circle);

    const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
    label.setAttribute("x", pos.x);
    label.setAttribute("y", pos.y + 5);
    label.setAttribute("text-anchor", "middle");
    label.classList.add("label");
    label.textContent = node;
    svg.appendChild(label);
  }
}

function updateTable() {
  tableBody.innerHTML = "";
  Object.keys(graph).forEach(node => {
    const tr = document.createElement("tr");
    const td1 = document.createElement("td"); td1.textContent = node;
    const td2 = document.createElement("td"); td2.textContent = distances[node] === Infinity ? "∞" : distances[node];
    const td3 = document.createElement("td"); td3.textContent = predecessors[node] || "-";
    tr.append(td1, td2, td3);
    tableBody.appendChild(tr);
  });
}

function log(message) {
  logDiv.textContent += message + "\n";
}

function enqueue(node) {
  queue.push(node);
  queue.sort((a,b) => distances[a] - distances[b]);
}

function dequeue() {
  return queue.shift();
}

function reconstructPath() {
  const path = [];
  let node = targetNode;
  while (node) {
    path.unshift(node);
    node = predecessors[node];
  }
  return path;
}

function highlightPath(path) {
  svg.querySelectorAll("line.edge").forEach(line => {
    line.classList.remove("highlight");
  });
  for (let i = 0; i < path.length - 1; i++) {
    const a = path[i], b = path[i+1];
    const edge = svg.querySelector(`line[data-edge='${a}-${b}'], line[data-edge='${b}-${a}']`);
    if (edge) edge.classList.add("highlight");
  }
}

function dijkstra() {
  Object.keys(graph).forEach(n => {
    distances[n] = Infinity;
    predecessors[n] = null;
  });
  distances[startNode] = 0;
  enqueue(startNode);

  log(`Running Dijkstra from ${startNode} to ${targetNode}...\n`);

  while (queue.length > 0) {
    const current = dequeue();
    visited.add(current);
    if (current === targetNode) break;

    for (const [neighbor, weight] of Object.entries(graph[current])) {
      if (visited.has(neighbor)) continue;
      const newDist = distances[current] + weight;
      if (newDist < distances[neighbor]) {
        distances[neighbor] = newDist;
        predecessors[neighbor] = current;
        enqueue(neighbor);
        log(`Update ${neighbor}: distance=${newDist} via ${current}`);
        updateTable();
      }
    }
  }

  const path = reconstructPath();
  if (distances[targetNode] < Infinity) {
    log(`\nShortest path: ${path.join(" → ")}`);
    log(`Total distance: ${distances[targetNode]}`);
    highlightPath(path);
  } else {
    log("No path found.");
  }

  updateTable();
}

drawGraph();
dijkstra();
</script>

</body>
</html>
